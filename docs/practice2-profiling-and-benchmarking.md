# Практика 2: Профилирование и бенчмаркинг

## Цели

__Цель данной работы__ — познакомиться с source-level подходом к профилированию,
практикой написания тестов на производительность, их запуска и анализа метрик
производительности. В результате выполнения практического задания должно
сформироваться общее представление о поиске узких мест в приложении и процессе
бенчмаркинга, в данном случае понимаемого как регрессионное тестирование
производительности.

## Задачи

  1. Проанализировать время работы фильтра скелетонизации, понять сколько
     времени потребляет каждая из функций. Определить самые медленные функции,
     которые требуют оптимизации.
  1. Реализовать набор тестов на производительность. В первую очередь должны
     тестироваться сценарии, похожие на тот, который возникает в
     демо-приложении. Это важно, поскольку именно их мы впоследствии будем
     оптимизировать. Кроме того, следует добавить и другие тесты на
     производительноть.
  1. Собрать несколько отчетов с метриками по производительности. В частности,
     можно проанализировать, насколько замедляет приложение сохранение
     изображений и замеры времени. Построить сравнительный отчет.

## Общая последовательность действий

  1. Инструментируем функцию `skeletonize` замерами времени (макросы `TS` и
     `TE`). Запускаем демо-приложение и анализируем время работы каждого шага.
     Проверяем, что сумма шагов примерно равна общему времени работы приложения.
  1. Прежде чем учиться писать тесты, стоит научиться их запускать и
     анализировать собранные метрики. Для этого запускаем сборку `perf_skeleton`
     с опцией сохранения XML-отчета. Затем анализируем метрики при помощи
     скриптов из OpenCV (`summary.py`, `report.py`). Детальные инструкции можно
     найти [здесь][using-perf-tests]. Также полезно сохранить несколько отчетов,
     и сравнить их друг с другом. Разброс значений стоит сопоставить с тем, что
     мы наблюдали при запуске демо-приложения.
  1. Далее пишем тест производительности на функцию `skeletonize`. Это делается
     в файле `perf/perf_skeleton`. Инструкции можно посмотреть в
     [документации][writing-perf-tests] к OpenCV. Проверяем, что время работы
     теста примерно равно тому времени, которое мы видели в консоли. Если
     имеются существенные различия, стараемся добиться похожих результатов,
     как правило разница в параметрах вызова функций.
  1. В качестве последнего шага стоит реализовать тесты производительности на
     три основных шага алгоритма: функции `ConvertColor_BGR2GRAY_BT709`,
     `ImageResize` и `GuoHallThinning`. Здесь также необходимо имитировать
     сценарий использования, аналогичный тому, что был в демо-приложении, чтобы
     получить похожие времена работы. Именно эти тесты впоследствии должны
     использоваться для анализа ваших ускорений.

## Детальная инструкция по выполнению работы

Прежде чем приступить к выполнению практической работы, рекомендуется получить
свежие версии файлов из центрального репозитория. Это обычный шаг, с этого как
правило начинают день программисты. И мы сразу же создаем новую ветку для
выполнения второго практического задания.

  ```txt
  $ cd <itseez-ws-2016-practice>
  $ git checkout master
  $ git pull origin master
  $ git checkout -b profiling-and-benchmarking
  ```

### Профилирование

  1. Далее нужно выполнить инструментацию функции `skeletonize` замерами
     времени, чтобы понять, на что тратится время внутри нее. Для этого
     открываем ее код и обрамляем основные функции макросами `TS` и `TE`, как
     это сделано для функции `imwrite`.

  1. После этого нужно построить и запустить демо-приложение. Первое, в чем
     нужно убедиться, это что сумма времени работы отдельных функций примерно
     дает суммарное время работы алгоритма (таймер `TIMER_total` в консоли).
     Если сумма примерно равна общему времени работы алгоритма, значит вы
     знаете, где тратит свое время программа.

  1. Далее запускаем демо-приложение с опцией `--save` и без нее. Смотрим, какую
     часть времени приложение тратило на сохранение изображений. Далее всегда
     работаем без опции `--save`, поскольку она сильно замедляет работу
     алгоритма. Это понятно, поскольку в данном случае идет работа с жестким
     диском, и она нас точно не интересует с точки зрения работы алгоритма.

     ```txt
     $ cd <itseez-ws-2016-practice-build>
     $ ./bin/skeleton --image ./bin/testdata/sla.png --save
     $ ./bin/skeleton --image ./bin/testdata/sla.png
     ```

  1. Затем следует проанализировать разброс в замерах времени. Для этого
     запускаем демо-приложение несколько раз и записываем например на листочке
     времена работы. Оцениваем разброс значений, хотя бы просто "на глазок".
     Потом мы сравним эти значения с теми, что дают тесты производительности.

### Анализ метрик производительности

В тестовую сборку уже включен некий тест производительности, и в этом разделе
мы научимся запускать его, сохранять метрики производительности в XML-файл, и
затем анализировать их при помощи вспомогательных скриптов.

  1. Итак, первым делом стоит запустить сборку с тестами на производительность.
     Это можно сделать при помощи команды ниже, и вы должны увидеть следующий
     вывод.

     ```txt
     $ cd <itseez-ws-2016-practice-build>
     $ ./bin/perf_skeleton

     [==========] Running 3 tests from 1 test case.
     [----------] Global test environment set-up.
     [----------] 3 tests from Size_Only_ImageResize
     [ RUN      ] Size_Only_ImageResize.ImageResize/0
     [ VALUE    ]  640x480
     [       OK ] Size_Only_ImageResize.ImageResize/0 (5 ms)
     [ RUN      ] Size_Only_ImageResize.ImageResize/1
     [ VALUE    ]  1280x720
     [       OK ] Size_Only_ImageResize.ImageResize/1 (8 ms)
     [ RUN      ] Size_Only_ImageResize.ImageResize/2
     [ VALUE    ]  1920x1080
     [       OK ] Size_Only_ImageResize.ImageResize/2 (16 ms)
     [----------] 3 tests from Size_Only_ImageResize (29 ms total)

     [----------] Global test environment tear-down
     [==========] 3 tests from 1 test case ran. (29 ms total)
     [  PASSED  ] 3 tests.
     ```

  1. Однако в случае выше мы не сделали главного — мы не сохранили метрики
     производительности. Нужно понимать, что те числа, которые вывелись на
     консоль, не имеют отношения к производительности, поскольку функции
     выполнялись в цикле `TEST_CYCLE()` по несколько раз. Чтобы сохранить
     метрики, нужно указать имя XML-файла:

    ```txt
     $ cd <itseez-ws-2016-practice-build>
     $ ./bin/perf_skeleton --gtest_output=xml:perf_report.xml
    ```

  1. Далее стоит проанализировать содержимое собранного отчета. Детальную
     информацию по метрикам можно получить при помощи скрипта `report.py` из
     OpenCV:

     ```txt
      $ ../itseez-ws-2016-practice/3rdparty/opencv_ptest/misc/report.py ./perf_report.xml
     ```

     На консоль выведется полная статистика по метрикам:

     ```txt
               Name of Test                Number of     Number of   Min     Median  Geometric mean   Mean   Standard deviation
                                       collected samples outliers
     ImageResize::Size_Only::1280x720         100            2     5.40 ms  5.44 ms     5.66 ms     5.69 ms       0.59 ms
     ImageResize::Size_Only::1920x1080        100            0     12.21 ms 12.39 ms    12.95 ms    12.99 ms      1.04 ms
     ImageResize::Size_Only::640x480          100            4     1.80 ms  1.81 ms     1.91 ms     1.92 ms       0.25 ms
     ```

  1. Следующий скрипт позволяет сравнивать между собой несколько отчетов,
     например за разные дни или на разных этапах оптимизации. Мы для простоты
     просто запустим сборку с тестами по производительности несколько раз, и
     сравним отчеты между собой.

     ```txt
     $ ./bin/perf_skeleton --gtest_output=xml:perf_report_1.xml
     $ ./bin/perf_skeleton --gtest_output=xml:perf_report_2.xml
     $ ./bin/perf_skeleton --gtest_output=xml:perf_report_3.xml
     $ ../itseez-ws-2016-practice/3rdparty/opencv_ptest/misc/summary.py ./perf_report*
     ```

  1. Сравните колебания усредненных метрик с теми, что мы наблюдали при запуске
     демо-приложения.

### Реализация тестов производительности


<!-- LINKS -->

[writing-perf-tests]: https://github.com/Itseez/opencv/wiki/HowToWritePerfTests
[using-perf-tests]:   https://github.com/Itseez/opencv/wiki/HowToUsePerfTests
